---
title: "Sliderコンポーネントの構築"
description: "ドラッグ可能なサム、キーボード矢印/Home/Endサポート、role='slider'セマンティクス、トラックフィル用CSSカスタムプロパティを備えたアクセシブルなSliderの構築方法を学びます。"
order: 2
isFree: false
---

# Sliderコンポーネントの構築

**Slider**は、トラックに沿ってサムをドラッグすることで数値を選択するコンポーネントです。Sliderは音量コントロール、価格フィルター、カラーピッカーでよく使われます。ゼロから構築するには、ポインターイベント処理、キーボードナビゲーション、ARIAセマンティクス、視覚的なトラックフィルのためのCSSカスタムプロパティが必要です。

## ARIA Sliderパターン

WAI-ARIA仕様は `slider` ロールを定義しています：

| 属性 | 目的 | 例 |
|-----------|---------|---------|
| `role="slider"` | 要素をスライダーとして識別 | サムに適用 |
| `aria-valuenow` | 現在の値 | `50` |
| `aria-valuemin` | 最小値 | `0` |
| `aria-valuemax` | 最大値 | `100` |
| `aria-valuetext` | 人間が読める値 | `"50%"` |
| `aria-orientation` | スライダーの方向 | `"horizontal"` |
| `aria-label` | アクセシブル名 | `"Volume"` |

スクリーンリーダーは「音量、スライダー、50、最小0、最大100」と読み上げます。

<Callout type="info">
`aria-valuetext` 属性はオプションですが、生の数値にコンテキストがない場合に有用です。温度スライダーの場合、`aria-valuetext="72 degrees Fahrenheit"` は `aria-valuenow="72"` だけよりもはるかに意味が伝わります。
</Callout>

## キーボード操作

| キー | アクション |
|-----|--------|
| `ArrowRight` / `ArrowUp` | stepずつインクリメント |
| `ArrowLeft` / `ArrowDown` | stepずつデクリメント |
| `Home` | 最小値に設定 |
| `End` | 最大値に設定 |
| `Page Up` | 大きなステップ（10倍）でインクリメント |
| `Page Down` | 大きなステップ（10倍）でデクリメント |

## コンポーネントAPI設計

```tsx
interface SliderProps {
  value?: number;
  defaultValue?: number;
  onValueChange?: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
  orientation?: "horizontal" | "vertical";
  disabled?: boolean;
}
```

複合コンポーネント：

- **`Slider.Root`** — 値の状態を管理し、コンテキストを提供し、トラック上のポインターイベントを処理します。
- **`Slider.Track`** — トラック全体の領域。
- **`Slider.Range`** — 現在の値を表すトラックのフィル部分。
- **`Slider.Thumb`** — ARIA `slider` ロールを持つドラッグ可能なハンドル。

## ポインターイベント処理

ドラッグ操作は標準的なポインターキャプチャパターンに従います：

1. **トラック上の `onPointerDown`**：クリック位置から値を計算し、トラッキングを開始します。
2. **`onPointerMove`**：ポインターの移動に応じて値を更新します。ポインターが要素から離れてもイベントを受信し続けるために `setPointerCapture` を使用します。
3. **`onPointerUp`**：ポインターキャプチャを解放し、トラッキングを停止します。

```tsx
function calculateValue(
  clientX: number,
  trackRect: DOMRect,
  min: number,
  max: number,
  step: number,
): number {
  const percent = (clientX - trackRect.left) / trackRect.width;
  const raw = min + percent * (max - min);
  const stepped = Math.round((raw - min) / step) * step + min;
  return Math.min(Math.max(stepped, min), max);
}
```

<Callout type="warning">
`pointerdown` では必ず `setPointerCapture` を使用してください。これがないと、ユーザーがサムを素早くドラッグしてカーソルがトラック要素から離れた場合、`pointermove` イベントの受信が停止し、ドラッグが「壊れ」ます。
</Callout>

## トラックフィル用CSSカスタムプロパティ

JavaScriptでインラインの幅を計算する代わりに、コンシューマーがスタイリングに使用できるCSSカスタムプロパティを公開します：

```tsx
const percentage = ((value - min) / (max - min)) * 100;
const style = {
  "--slider-value": `${percentage}%`,
  "--slider-thumb-position": `${percentage}%`,
} as React.CSSProperties;
```

これにより純粋なCSSスタイリングが可能になります：

```css
.slider-range {
  width: var(--slider-value);
}

.slider-thumb {
  left: var(--slider-thumb-position);
}
```

## 完全な実装

```tsx
import * as React from "react";

interface SliderContextValue {
  value: number;
  min: number;
  max: number;
  step: number;
  disabled: boolean;
  orientation: "horizontal" | "vertical";
  percentage: number;
  thumbRef: React.RefObject<HTMLDivElement | null>;
  trackRef: React.RefObject<HTMLDivElement | null>;
  updateValue: (next: number) => void;
}

const SliderContext = React.createContext<SliderContextValue | null>(null);

function useSliderContext() {
  const ctx = React.useContext(SliderContext);
  if (!ctx) throw new Error("Slider sub-components must be used within Slider.Root");
  return ctx;
}

function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

function Root({
  value: controlledValue,
  defaultValue = 0,
  onValueChange,
  min = 0,
  max = 100,
  step = 1,
  orientation = "horizontal",
  disabled = false,
  children,
  ...props
}: SliderProps & React.ComponentPropsWithoutRef<"div">) {
  const [internalValue, setInternalValue] = React.useState(controlledValue ?? defaultValue);
  const value = controlledValue ?? internalValue;
  const trackRef = React.useRef<HTMLDivElement>(null);
  const thumbRef = React.useRef<HTMLDivElement>(null);
  const percentage = ((value - min) / (max - min)) * 100;

  const updateValue = React.useCallback(
    (next: number) => {
      const clamped = clamp(next, min, max);
      const stepped = Math.round((clamped - min) / step) * step + min;
      const final = clamp(stepped, min, max);
      if (controlledValue === undefined) setInternalValue(final);
      onValueChange?.(final);
    },
    [min, max, step, controlledValue, onValueChange],
  );

  const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    if (disabled) return;
    const track = trackRef.current;
    if (!track) return;

    e.currentTarget.setPointerCapture(e.pointerId);
    const rect = track.getBoundingClientRect();
    const percent = orientation === "horizontal"
      ? (e.clientX - rect.left) / rect.width
      : (rect.bottom - e.clientY) / rect.height;
    const raw = min + percent * (max - min);
    updateValue(raw);
    thumbRef.current?.focus();
  };

  const handlePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (disabled) return;
    if (!e.currentTarget.hasPointerCapture(e.pointerId)) return;
    const track = trackRef.current;
    if (!track) return;

    const rect = track.getBoundingClientRect();
    const percent = orientation === "horizontal"
      ? (e.clientX - rect.left) / rect.width
      : (rect.bottom - e.clientY) / rect.height;
    const raw = min + percent * (max - min);
    updateValue(raw);
  };

  const ctx = React.useMemo(
    () => ({ value, min, max, step, disabled, orientation, percentage, thumbRef, trackRef, updateValue }),
    [value, min, max, step, disabled, orientation, percentage, updateValue],
  );

  return (
    <SliderContext value={ctx}>
      <div
        data-orientation={orientation}
        data-disabled={disabled || undefined}
        style={{ "--slider-value": `${percentage}%`, "--slider-thumb-position": `${percentage}%` } as React.CSSProperties}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        {...props}
      >
        {children}
      </div>
    </SliderContext>
  );
}

function Track({ children, ...props }: React.ComponentPropsWithoutRef<"div">) {
  const { trackRef, orientation } = useSliderContext();

  return (
    <div ref={trackRef} data-orientation={orientation} {...props}>
      {children}
    </div>
  );
}

function Range(props: React.ComponentPropsWithoutRef<"div">) {
  const { percentage, orientation } = useSliderContext();

  const style = orientation === "horizontal"
    ? { width: `${percentage}%` }
    : { height: `${percentage}%` };

  return <div data-orientation={orientation} style={style} {...props} />;
}

function Thumb(props: React.ComponentPropsWithoutRef<"div">) {
  const { value, min, max, step, disabled, orientation, percentage, thumbRef, updateValue } =
    useSliderContext();

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (disabled) return;

    switch (e.key) {
      case "ArrowRight":
      case "ArrowUp":
        e.preventDefault();
        updateValue(value + step);
        break;
      case "ArrowLeft":
      case "ArrowDown":
        e.preventDefault();
        updateValue(value - step);
        break;
      case "Home":
        e.preventDefault();
        updateValue(min);
        break;
      case "End":
        e.preventDefault();
        updateValue(max);
        break;
      case "PageUp":
        e.preventDefault();
        updateValue(value + step * 10);
        break;
      case "PageDown":
        e.preventDefault();
        updateValue(value - step * 10);
        break;
    }
  };

  const positionStyle = orientation === "horizontal"
    ? { left: `${percentage}%` }
    : { bottom: `${percentage}%` };

  return (
    <div
      ref={thumbRef}
      role="slider"
      tabIndex={disabled ? -1 : 0}
      aria-valuenow={value}
      aria-valuemin={min}
      aria-valuemax={max}
      aria-orientation={orientation}
      aria-disabled={disabled || undefined}
      data-disabled={disabled || undefined}
      style={positionStyle}
      onKeyDown={handleKeyDown}
      {...props}
    />
  );
}

export const Slider = { Root, Track, Range, Thumb };
```

## `setPointerCapture` を理解する

ユーザーがドラッグを開始すると、ルート要素で `setPointerCapture(pointerId)` を呼び出します。これは2つの重要なことを行います：

1. **後続のすべてのポインターイベントがキャプチャ要素で発火します**。ポインターがその範囲外に移動しても同様です。
2. **ドラッグがスムーズに継続します**。カーソルがトラック領域を超えて移動しても中断されません。

ポインターキャプチャがないと、素早いドラッグでカーソルがサム要素から離れ、`pointermove` イベントが発火しなくなります — ガタガタした壊れたインタラクションになります。

## なぜサムが `role="slider"` を受け取るのか

ARIAモデルでは、ユーザーが操作するインタラクティブな要素が `slider` ロールを受け取ります。トラックはセマンティックな意味を持たない視覚コンテナです。サムはキーボードフォーカスが存在し、すべてのARIA値属性が配置される場所です。

## スタイリングパターン

```css
.slider-track {
  position: relative;
  height: 4px;
  background: var(--color-fill-secondary);
  border-radius: 2px;
}

.slider-range {
  position: absolute;
  height: 100%;
  background: var(--color-accent);
  border-radius: 2px;
}

.slider-thumb {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--color-accent);
  transform: translateX(-50%);
  cursor: grab;
}

.slider-thumb:active {
  cursor: grabbing;
}
```

## 重要なポイント

1. **サムに `role="slider"`** を使用し、`aria-valuenow`、`aria-valuemin`、`aria-valuemax` を設定します。
2. **矢印キー**で値をステップさせ、Home/Endで境界にジャンプし、Page Up/Downでより大きなステップを使用します。
3. **`setPointerCapture`** はカーソルのドリフトに耐えるスムーズなドラッグ操作に不可欠です。
4. **CSSカスタムプロパティ**（`--slider-value`、`--slider-thumb-position`）により、視覚スタイリングをコンポーネント内部から分離します。
5. **ステップにスナップ**するには、min/maxにクランプする前に最も近いステップ倍数に丸めます。
6. **水平・垂直両方向**で同じロジックを使い、軸を入れ替えるだけです。

## 実践してみよう

<Exercise id="slider-basic" />
