---
title: "Selectコンポーネントの構築"
description: "トリガー、Listboxポップアップ、キーボードナビゲーション、aria-activedescendant、単一選択を備えたアクセシブルなSelectコンポーネントを構築します。"
order: 2
isFree: false
---

# Selectコンポーネントの構築

**Select**コンポーネントはトリガーボタンとポップアップListboxを組み合わせ、ユーザーがオプションリストから単一の値を選択できるようにします。ネイティブの`<select>`要素とは異なり、カスタムSelectはスタイリング、アニメーション、オプションのレンダリングを完全に制御できます — ただし、アクセシビリティ契約を自分で完全に実装する必要があります。

## ARIA Roleと関係

Selectウィジェットには複数のARIA roleと属性が連携して動作します：

| 要素 | Role/属性 | 目的 |
|------|-----------|------|
| トリガーボタン | `role="combobox"` | comboboxトリガーとして識別 |
| トリガーボタン | `aria-haspopup="listbox"` | Listboxが表示されることを読み上げ |
| トリガーボタン | `aria-expanded` | ポップアップが開いているかを読み上げ |
| トリガーボタン | `aria-activedescendant` | ハイライトされたオプションの`id`を指す |
| ポップアップ | `role="listbox"` | 選択可能なオプションをグループ化 |
| 各オプション | `role="option"` | 選択可能なオプションとして識別 |

<Callout type="info">
WAI-ARIA comboboxパターンはSelect（ボタントリガー）とCombobox（入力トリガー）の両方に`role="combobox"`を使用します。違いは、Selectのトリガーが選択された値を表示するボタンであるのに対し、Comboboxのトリガーはフィルタリング用のテキスト入力であることです。
</Callout>

```tsx
<button
  role="combobox"
  aria-haspopup="listbox"
  aria-expanded={isOpen}
  aria-activedescendant={isOpen ? activeOptionId : undefined}
  aria-controls="listbox-id"
>
  {selectedLabel}
</button>
<ul role="listbox" id="listbox-id">
  <li role="option" id="opt-1" aria-selected="true">Apple</li>
  <li role="option" id="opt-2" aria-selected="false">Banana</li>
</ul>
```

## キーボードナビゲーション

Selectは以下のキーボードインタラクションをサポートする必要があります：

### 閉じているとき

| キー | アクション |
|------|----------|
| `Enter` / `Space` | Listboxを開く |
| `ArrowDown` | Listboxを開き、最初のオプションをハイライト |
| `ArrowUp` | Listboxを開き、最後のオプションをハイライト |

### 開いているとき

| キー | アクション |
|------|----------|
| `ArrowDown` | 次のオプションをハイライト |
| `ArrowUp` | 前のオプションをハイライト |
| `Home` | 最初のオプションをハイライト |
| `End` | 最後のオプションをハイライト |
| `Enter` / `Space` | ハイライトされたオプションを選択して閉じる |
| `Escape` | 選択せずに閉じる |
| `Tab` | ハイライトされたオプションを選択して閉じる |
| 印刷可能文字 | タイプアヘッド検索 |

## コンポーネントAPI設計

```tsx
interface SelectProps {
  value?: string;
  defaultValue?: string;
  onValueChange?: (value: string) => void;
  placeholder?: string;
}

interface OptionProps {
  value: string;
  disabled?: boolean;
}
```

コンパウンドコンポーネント：

- **`Select.Root`** — 開閉状態、選択された値、ハイライトされたインデックスを管理。
- **`Select.Trigger`** — Listboxを開くボタン。
- **`Select.Content`** — ポップアップListboxコンテナ。
- **`Select.Option`** — 個々の選択可能なオプション。
- **`Select.Value`** — トリガー内に選択された値を表示。

## 完全な実装

```tsx
import * as React from "react";

// --- Context ---

interface SelectContextValue {
  isOpen: boolean;
  setIsOpen: (open: boolean) => void;
  selectedValue: string;
  selectValue: (value: string) => void;
  highlightedIndex: number;
  setHighlightedIndex: (index: number) => void;
  options: React.RefObject<{ value: string; label: string; id: string }[]>;
  registerOption: (value: string, label: string, id: string) => void;
  listboxId: string;
  triggerRef: React.RefObject<HTMLButtonElement | null>;
}

const SelectContext = React.createContext<SelectContextValue | null>(null);

function useSelectContext() {
  const ctx = React.useContext(SelectContext);
  if (!ctx) throw new Error("Select components must be used within Select.Root");
  return ctx;
}

// --- Root ---

function Root({
  value: controlledValue,
  defaultValue = "",
  onValueChange,
  children,
}: SelectProps & { children: React.ReactNode }) {
  const [isOpen, setIsOpen] = React.useState(false);
  const [selectedValue, setSelectedValue] = React.useState(
    controlledValue ?? defaultValue,
  );
  const [highlightedIndex, setHighlightedIndex] = React.useState(-1);
  const options = React.useRef<{ value: string; label: string; id: string }[]>([]);
  const triggerRef = React.useRef<HTMLButtonElement>(null);
  const listboxId = `listbox-${React.useId()}`;

  const current = controlledValue ?? selectedValue;

  const selectValue = React.useCallback(
    (val: string) => {
      if (controlledValue === undefined) setSelectedValue(val);
      onValueChange?.(val);
      setIsOpen(false);
      triggerRef.current?.focus();
    },
    [controlledValue, onValueChange],
  );

  const registerOption = React.useCallback(
    (value: string, label: string, id: string) => {
      const exists = options.current.find((o) => o.value === value);
      if (!exists) {
        options.current.push({ value, label, id });
      }
    },
    [],
  );

  const ctx = React.useMemo(
    () => ({
      isOpen,
      setIsOpen,
      selectedValue: current,
      selectValue,
      highlightedIndex,
      setHighlightedIndex,
      options,
      registerOption,
      listboxId,
      triggerRef,
    }),
    [isOpen, current, selectValue, highlightedIndex, registerOption, listboxId],
  );

  return <SelectContext value={ctx}>{children}</SelectContext>;
}

// --- Trigger ---

function Trigger({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"button">) {
  const {
    isOpen,
    setIsOpen,
    highlightedIndex,
    setHighlightedIndex,
    options,
    listboxId,
    triggerRef,
  } = useSelectContext();

  const activeDescendant =
    highlightedIndex >= 0
      ? options.current[highlightedIndex]?.id
      : undefined;

  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown": {
        e.preventDefault();
        setIsOpen(true);
        setHighlightedIndex(0);
        break;
      }
      case "ArrowUp": {
        e.preventDefault();
        setIsOpen(true);
        setHighlightedIndex(options.current.length - 1);
        break;
      }
    }
  };

  return (
    <button
      ref={triggerRef}
      role="combobox"
      type="button"
      aria-haspopup="listbox"
      aria-expanded={isOpen}
      aria-controls={listboxId}
      aria-activedescendant={isOpen ? activeDescendant : undefined}
      onClick={() => {
        setIsOpen(!isOpen);
        if (!isOpen) setHighlightedIndex(0);
      }}
      onKeyDown={handleKeyDown}
      {...props}
    >
      {children}
    </button>
  );
}

// --- Value ---

function Value({ placeholder = "Select..." }: { placeholder?: string }) {
  const { selectedValue, options } = useSelectContext();
  const selected = options.current.find((o) => o.value === selectedValue);
  return <span>{selected ? selected.label : placeholder}</span>;
}

// --- Content ---

function Content({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"ul">) {
  const {
    isOpen,
    setIsOpen,
    highlightedIndex,
    setHighlightedIndex,
    options,
    selectValue,
    listboxId,
    triggerRef,
  } = useSelectContext();

  // タイプアヘッド
  const bufferRef = React.useRef("");
  const timeoutRef = React.useRef<ReturnType<typeof setTimeout>>();

  React.useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.key) {
        case "ArrowDown": {
          e.preventDefault();
          setHighlightedIndex(
            Math.min(highlightedIndex + 1, options.current.length - 1),
          );
          break;
        }
        case "ArrowUp": {
          e.preventDefault();
          setHighlightedIndex(Math.max(highlightedIndex - 1, 0));
          break;
        }
        case "Home": {
          e.preventDefault();
          setHighlightedIndex(0);
          break;
        }
        case "End": {
          e.preventDefault();
          setHighlightedIndex(options.current.length - 1);
          break;
        }
        case "Enter":
        case " ": {
          e.preventDefault();
          if (highlightedIndex >= 0) {
            selectValue(options.current[highlightedIndex].value);
          }
          break;
        }
        case "Escape": {
          e.preventDefault();
          setIsOpen(false);
          triggerRef.current?.focus();
          break;
        }
        case "Tab": {
          if (highlightedIndex >= 0) {
            selectValue(options.current[highlightedIndex].value);
          }
          break;
        }
        default: {
          // タイプアヘッド
          if (e.key.length === 1) {
            clearTimeout(timeoutRef.current);
            bufferRef.current += e.key.toLowerCase();

            const matchIndex = options.current.findIndex((opt) =>
              opt.label.toLowerCase().startsWith(bufferRef.current),
            );
            if (matchIndex !== -1) {
              setHighlightedIndex(matchIndex);
            }

            timeoutRef.current = setTimeout(() => {
              bufferRef.current = "";
            }, 500);
          }
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [isOpen, highlightedIndex, options, selectValue, setHighlightedIndex, setIsOpen, triggerRef]);

  // ハイライトされたオプションをビューにスクロール
  React.useEffect(() => {
    if (!isOpen || highlightedIndex < 0) return;
    const optionId = options.current[highlightedIndex]?.id;
    if (optionId) {
      document.getElementById(optionId)?.scrollIntoView({ block: "nearest" });
    }
  }, [isOpen, highlightedIndex, options]);

  if (!isOpen) return null;

  return (
    <ul role="listbox" id={listboxId} {...props}>
      {children}
    </ul>
  );
}

// --- Option ---

function Option({
  value,
  children,
  disabled = false,
  ...props
}: OptionProps & React.ComponentPropsWithoutRef<"li">) {
  const {
    selectedValue,
    selectValue,
    highlightedIndex,
    setHighlightedIndex,
    options,
    registerOption,
  } = useSelectContext();

  const optionId = `option-${React.useId()}`;
  const label = typeof children === "string" ? children : value;

  React.useEffect(() => {
    registerOption(value, label, optionId);
  }, [value, label, optionId, registerOption]);

  const index = options.current.findIndex((o) => o.value === value);
  const isSelected = selectedValue === value;
  const isHighlighted = highlightedIndex === index;

  return (
    <li
      role="option"
      id={optionId}
      aria-selected={isSelected}
      aria-disabled={disabled || undefined}
      data-highlighted={isHighlighted || undefined}
      data-state={isSelected ? "selected" : undefined}
      onClick={() => {
        if (!disabled) selectValue(value);
      }}
      onPointerMove={() => {
        if (!disabled) setHighlightedIndex(index);
      }}
      {...props}
    >
      {children}
    </li>
  );
}

export const Select = { Root, Trigger, Value, Content, Option };
```

## フォーカス管理の詳細

Selectのフォーカス管理における重要な知見は、ポップアップが開いている間も**DOMフォーカスはトリガーボタンに留まる**ということです。トリガーの`aria-activedescendant`属性がスクリーンリーダーにどのオプションがハイライトされているかを伝えます：

```
DOMフォーカス: [トリガーボタン]
  aria-activedescendant="option-banana"
  → スクリーンリーダーが読み上げ: "Banana"
```

このアプローチにより、DOMフォーカスをポップアップに移動する必要がなくなり、フォーカストラップやフォーカス復元に関する課題を回避できます。

<Callout type="warning">
ポップアップ内の個々の`<li>`要素にDOMフォーカスを移動してはいけません。フォーカスはトリガーに保持し、`aria-activedescendant`を使用してください。Listboxにフォーカスを移動すると、期待されるインタラクションパターンが壊れ、スクリーンリーダーを混乱させる可能性があります。
</Callout>

## 外側クリックで閉じる

ユーザーがSelectポップアップの外側をクリックした場合、選択を変更せずに閉じるべきです：

```tsx
React.useEffect(() => {
  if (!isOpen) return;

  const handlePointerDown = (e: PointerEvent) => {
    const target = e.target as Node;
    const trigger = triggerRef.current;
    const listbox = document.getElementById(listboxId);

    if (trigger?.contains(target) || listbox?.contains(target)) return;
    setIsOpen(false);
  };

  document.addEventListener("pointerdown", handlePointerDown);
  return () => document.removeEventListener("pointerdown", handlePointerDown);
}, [isOpen, listboxId, setIsOpen, triggerRef]);
```

## スタイリング戦略

### ハイライトと選択の視覚状態

これらは2つの独立した状態です — オプションはハイライトと選択の両方を同時に持つことができます：

```css
[role="option"][data-highlighted] {
  background: var(--color-accent-subtle);
}

[role="option"][data-state="selected"] {
  font-weight: 600;
}

/* 両方の状態の組み合わせ */
[role="option"][data-highlighted][data-state="selected"] {
  background: var(--color-accent-subtle);
  font-weight: 600;
}
```

### ポップアップの配置

プロダクション用途では、Floating UIのようなポジショニングライブラリを使用します。このコースでは、absolute positioningで十分です：

```css
.select-root {
  position: relative;
}

.select-content {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  max-height: 240px;
  overflow-y: auto;
  border: 1px solid var(--color-border);
  border-radius: 8px;
  background: var(--color-surface);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 50;
}
```

## よくある落とし穴

| ミス | 壊れる理由 |
|------|-----------|
| トリガーに`role="listbox"`を使用 | トリガーは`combobox`、ポップアップが`listbox` |
| `aria-activedescendant`を忘れる | スクリーンリーダーがどのオプションがハイライトされているか追跡できない |
| `<li>`要素にDOMフォーカスを移動 | フォーカス管理が壊れ、フォーカス復元が複雑になる |
| 閉じるときにトリガーにフォーカスを戻さない | キーボードユーザーがページ内で迷子になる |
| ハイライトに`aria-selected`を使用 | ハイライトと選択は異なる状態 |

## 重要なポイント

1. **Select = トリガー（`combobox`）+ ポップアップ（`listbox`）。** DOMフォーカスはトリガーに保持。
2. **`aria-activedescendant`**をトリガーに設定し、ハイライトされたオプションをスクリーンリーダーに伝えます。
3. **`aria-expanded`**はポップアップが開いているか閉じているかをユーザーに伝えます。
4. **`aria-selected`**は現在選択されている値をマークし、ハイライトされたオプションではありません。
5. **タイプアヘッド**により文字入力でオプションにジャンプできます。
6. **外側クリック**と**Escape**は選択を変更せずにポップアップを閉じます。
7. **フォーカス復元**はポップアップが閉じるときにトリガーに戻すことが不可欠です。

## 自分で試してみよう

<Exercise id="select-basic" />
