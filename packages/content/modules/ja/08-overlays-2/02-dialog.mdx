---
title: "Dialogコンポーネントの構築"
description: "フォーカストラップ、Portalレンダリング、Escapeで閉じる、スクロールロック、role=dialog、aria-modalを備えたアクセシブルなDialogの構築方法を学びます。"
order: 2
isFree: false
---

# Dialogコンポーネントの構築

**Dialog**（モーダルとも呼ばれる）は、背後のページとのインタラクションをブロックするオーバーレイウィンドウです。ダイアログはユーザーの注意を要求します — メインコンテンツに戻るにはダイアログに応答しなければなりません。そのため、ダイアログは最も「攻撃的な」UIパターンであり、ユーザーのワークフローを中断する必要がある場合にのみ控えめに使用すべきです。

## Dialogを使うべきとき

| Dialogを使う | Dialogを使わない |
|-------------|-----------------|
| 破壊的なアクションの確認 | シンプルなステータスメッセージの表示（Toastを使用） |
| 必須の入力の収集 | 補足情報の表示（Popoverを使用） |
| 複数ステップのワークフロー | ナビゲーションメニュー（メニューまたはナビゲーションを使用） |
| アクションが必要な重要なアラート | ブロッキングでない通知（バナーを使用） |

## ARIAセマンティクス

WAI-ARIA仕様はモーダルダイアログに正確なセマンティクスを定義しています：

| 属性 | 適用先 | 目的 |
|------|--------|------|
| `role="dialog"` | Dialogコンテナ | 要素をダイアログとして識別 |
| `aria-modal="true"` | Dialogコンテナ | 背後のコンテンツがinertであることを支援技術に通知 |
| `aria-labelledby` | Dialogコンテナ | ダイアログのタイトル要素を指す |
| `aria-describedby` | Dialogコンテナ | ダイアログの説明を指す（オプション） |

スクリーンリーダーがこれらの属性を持つダイアログに遭遇すると、「ダイアログ：[タイトル]。[説明]。」と読み上げ、仮想カーソルをダイアログコンテンツ内に限定します。

```tsx
<div
  role="dialog"
  aria-modal="true"
  aria-labelledby="dialog-title"
  aria-describedby="dialog-desc"
>
  <h2 id="dialog-title">Delete Account</h2>
  <p id="dialog-desc">This action cannot be undone.</p>
  <button>Cancel</button>
  <button>Delete</button>
</div>
```

<Callout type="warning">
`aria-modal="true"`はスクリーンリーダーに仮想カーソルをダイアログ内に限定するよう指示しますが、キーボードフォーカスがダイアログから離れることは防止しません。そのためには適切なフォーカストラップを実装する必要があります。これらは補完的なメカニズムです。
</Callout>

## コンポーネントAPI設計

```tsx
interface DialogProps {
  open?: boolean;
  defaultOpen?: boolean;
  onOpenChange?: (open: boolean) => void;
}
```

コンパウンドコンポーネント：

- **`Dialog.Root`** — 開閉状態を管理。
- **`Dialog.Trigger`** — ダイアログを開くボタン。
- **`Dialog.Portal`** — 子要素をPortalにレンダリング。
- **`Dialog.Overlay`** — ダイアログの背後の背景幕。
- **`Dialog.Content`** — フォーカストラップを持つダイアログパネル。
- **`Dialog.Title`** — `aria-labelledby`でリンクされるダイアログの見出し。
- **`Dialog.Description`** — `aria-describedby`でリンクされるオプションの説明。
- **`Dialog.Close`** — ダイアログを閉じるボタン。

## 完全な実装

```tsx
import * as React from "react";
import { createPortal } from "react-dom";

// --- Context ---

interface DialogContextValue {
  open: boolean;
  setOpen: (open: boolean) => void;
  titleId: string;
  descriptionId: string;
  triggerRef: React.RefObject<HTMLButtonElement | null>;
  contentRef: React.RefObject<HTMLDivElement | null>;
}

const DialogContext = React.createContext<DialogContextValue | null>(null);

function useDialogContext() {
  const ctx = React.useContext(DialogContext);
  if (!ctx) throw new Error("Dialog components must be used within Dialog.Root");
  return ctx;
}

// --- Root ---

function Root({
  open: controlledOpen,
  defaultOpen = false,
  onOpenChange,
  children,
}: DialogProps & { children: React.ReactNode }) {
  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(defaultOpen);
  const open = controlledOpen ?? uncontrolledOpen;
  const triggerRef = React.useRef<HTMLButtonElement | null>(null);
  const contentRef = React.useRef<HTMLDivElement | null>(null);
  const titleId = React.useId();
  const descriptionId = React.useId();

  const setOpen = React.useCallback(
    (nextOpen: boolean) => {
      if (controlledOpen === undefined) setUncontrolledOpen(nextOpen);
      onOpenChange?.(nextOpen);
    },
    [controlledOpen, onOpenChange],
  );

  const ctx = React.useMemo(
    () => ({ open, setOpen, titleId, descriptionId, triggerRef, contentRef }),
    [open, setOpen, titleId, descriptionId],
  );

  return <DialogContext value={ctx}>{children}</DialogContext>;
}

// --- Trigger ---

function Trigger({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"button">) {
  const { setOpen, triggerRef } = useDialogContext();

  return (
    <button
      ref={triggerRef}
      type="button"
      onClick={() => setOpen(true)}
      {...props}
    >
      {children}
    </button>
  );
}

// --- Portal ---

function Portal({ children }: { children: React.ReactNode }) {
  const { open } = useDialogContext();
  if (!open) return null;
  return createPortal(
    <div data-portal="">{children}</div>,
    document.body,
  );
}

// --- Overlay ---

function Overlay({
  className,
  ...props
}: React.ComponentPropsWithoutRef<"div">) {
  const { setOpen } = useDialogContext();

  return (
    <div
      className={className}
      data-dialog-overlay=""
      onClick={() => setOpen(false)}
      aria-hidden="true"
      {...props}
    />
  );
}

// --- Content ---

function Content({
  children,
  className,
  ...props
}: React.ComponentPropsWithoutRef<"div">) {
  const { open, setOpen, titleId, descriptionId, triggerRef, contentRef } =
    useDialogContext();

  // フォーカストラップのセンチネル
  const getFocusableElements = () => {
    if (!contentRef.current) return [];
    return Array.from(
      contentRef.current.querySelectorAll<HTMLElement>(
        'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])',
      ),
    );
  };

  const handleSentinelFocus = (position: "start" | "end") => {
    const focusable = getFocusableElements();
    if (focusable.length === 0) return;
    if (position === "start") {
      focusable[focusable.length - 1].focus();
    } else {
      focusable[0].focus();
    }
  };

  // 初期フォーカス
  React.useEffect(() => {
    if (!open || !contentRef.current) return;

    const autoFocusTarget =
      contentRef.current.querySelector<HTMLElement>("[data-autofocus]");
    if (autoFocusTarget) {
      autoFocusTarget.focus();
      return;
    }

    const focusable = getFocusableElements();
    if (focusable.length > 0) {
      focusable[0].focus();
    } else {
      contentRef.current.focus();
    }
  }, [open]);

  // Escapeキー
  React.useEffect(() => {
    if (!open) return;
    function handleKeyDown(e: KeyboardEvent) {
      if (e.key === "Escape") {
        setOpen(false);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [open, setOpen]);

  // スクロールロック
  React.useEffect(() => {
    if (!open) return;
    const scrollY = window.scrollY;
    document.body.style.overflow = "hidden";
    document.body.style.position = "fixed";
    document.body.style.top = `-${scrollY}px`;
    document.body.style.width = "100%";

    return () => {
      document.body.style.overflow = "";
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.width = "";
      window.scrollTo(0, scrollY);
    };
  }, [open]);

  // 兄弟要素をinertに
  React.useEffect(() => {
    if (!open) return;
    const portal = contentRef.current?.closest("[data-portal]");
    const siblings = Array.from(document.body.children).filter(
      (el) => el !== portal,
    );
    siblings.forEach((el) => el.setAttribute("inert", ""));
    return () => siblings.forEach((el) => el.removeAttribute("inert"));
  }, [open]);

  // 閉じるときにフォーカスを戻す
  React.useEffect(() => {
    if (!open) {
      triggerRef.current?.focus();
    }
  }, [open, triggerRef]);

  return (
    <>
      <div
        tabIndex={0}
        onFocus={() => handleSentinelFocus("start")}
        aria-hidden="true"
        style={{ position: "fixed", opacity: 0, pointerEvents: "none" }}
      />
      <div
        ref={contentRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby={titleId}
        aria-describedby={descriptionId}
        tabIndex={-1}
        className={className}
        {...props}
      >
        {children}
      </div>
      <div
        tabIndex={0}
        onFocus={() => handleSentinelFocus("end")}
        aria-hidden="true"
        style={{ position: "fixed", opacity: 0, pointerEvents: "none" }}
      />
    </>
  );
}

// --- Title ---

function Title({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"h2">) {
  const { titleId } = useDialogContext();
  return (
    <h2 id={titleId} {...props}>
      {children}
    </h2>
  );
}

// --- Description ---

function Description({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"p">) {
  const { descriptionId } = useDialogContext();
  return (
    <p id={descriptionId} {...props}>
      {children}
    </p>
  );
}

// --- Close ---

function Close({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"button">) {
  const { setOpen } = useDialogContext();
  return (
    <button type="button" onClick={() => setOpen(false)} {...props}>
      {children}
    </button>
  );
}

export const Dialog = {
  Root,
  Trigger,
  Portal,
  Overlay,
  Content,
  Title,
  Description,
  Close,
};
```

## インタラクションフローの理解

ダイアログインタラクションの完全なライフサイクルは以下の通りです：

```
1. ユーザーがTriggerをクリック
   └─ setOpen(true)
   └─ PortalがDocument.bodyにマウント
   └─ Overlayがレンダリング（背景クリックをブロック）
   └─ Contentがセンチネル付きでレンダリング
   └─ 兄弟要素にinert属性が設定
   └─ bodyのスクロールがロック
   └─ 最初のフォーカス可能な要素にフォーカスが移動

2. ユーザーがダイアログと対話
   └─ Tab/Shift+Tabがセンチネル内で循環
   └─ Escapeキー → setOpen(false)
   └─ Overlayクリック → setOpen(false)
   └─ Closeボタン → setOpen(false)

3. ダイアログが閉じる
   └─ Portalがアンマウント
   └─ 兄弟要素からinert属性が削除
   └─ bodyのスクロールがアンロック
   └─ フォーカスがTriggerに戻る
```

## 使用例

```tsx
function DeleteConfirmation() {
  return (
    <Dialog.Root>
      <Dialog.Trigger>Delete Account</Dialog.Trigger>
      <Dialog.Portal>
        <Dialog.Overlay className="dialog-overlay" />
        <Dialog.Content className="dialog-content">
          <Dialog.Title>Delete Account</Dialog.Title>
          <Dialog.Description>
            This will permanently delete your account and all associated data.
            This action cannot be undone.
          </Dialog.Description>
          <div className="dialog-actions">
            <Dialog.Close>Cancel</Dialog.Close>
            <button onClick={handleDelete}>Delete Forever</button>
          </div>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
}
```

## CSSの戦略

```css
.dialog-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 50;
}

.dialog-content {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--color-surface);
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  max-width: 480px;
  width: calc(100% - 32px);
  z-index: 51;
}

.dialog-content:focus-visible {
  outline: 2px solid var(--color-accent);
  outline-offset: 2px;
}
```

<Callout type="tip">
ダイアログコンテンツは`position: fixed`と`transform: translate(-50%, -50%)`を使って中央配置しています。これはDOM内のPortalの位置に依存せず、親要素のスタイリングに関係なく動作します。
</Callout>

## アニメーションパターン

表示/非表示アニメーションには`data-state`属性を使用します：

```css
.dialog-overlay[data-state="open"] {
  animation: fadeIn 200ms ease-out;
}

.dialog-content[data-state="open"] {
  animation: slideIn 200ms ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { opacity: 0; transform: translate(-50%, -48%) scale(0.96); }
  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

@media (prefers-reduced-motion: reduce) {
  .dialog-overlay[data-state="open"],
  .dialog-content[data-state="open"] {
    animation: none;
  }
}
```

## 重要なポイント

1. **`role="dialog"` + `aria-modal="true"`**はスクリーンリーダーにダイアログセマンティクスを定義します。
2. **`aria-labelledby`**はダイアログをそのタイトルにリンクし、適切な読み上げを提供します。
3. **フォーカストラップ**はセンチネル要素でTabがダイアログから離れることを防ぎます。
4. **`inert`**は兄弟要素に設定し、背景コンテンツを支援技術から隠します。
5. **スクロールロック**はダイアログが開いている間、背景のスクロールを防ぎます。
6. **Escapeキー**はダイアログを閉じる必要があります。
7. **Overlayクリック**は標準ダイアログを閉じるべきです（ただしアラートダイアログは除く — 次のレッスンで解説）。
8. **フォーカスリターン**でダイアログが閉じるときにトリガー要素に戻ります。

## 自分で試してみよう

<Exercise id="dialog-basic" />
