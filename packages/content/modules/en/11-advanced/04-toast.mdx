---
title: "Building a Toast/Notification System"
description: "Learn how to build a Toast notification system with queue management, auto-dismiss timers, pause-on-hover, role='status'/role='alert', and swipe-to-dismiss."
order: 4
isFree: false
---

# Building a Toast/Notification System

A **Toast** (also called a "notification" or "snackbar") is a brief, non-modal message that appears temporarily to inform the user about an action's result. Toasts are unique among UI components because they operate as a *system* rather than a single element: multiple toasts can queue up, each with its own lifecycle.

## Design Challenges

Toasts introduce several challenges not found in simpler components:

1. **Queue management**: Multiple toasts can appear simultaneously. You need to decide how many are visible, how they stack, and the order they dismiss.
2. **Auto-dismiss timing**: Each toast has a configurable duration before it vanishes. The timer should pause when the user hovers or focuses, giving them time to read.
3. **Imperative API**: Unlike most React components that are rendered declaratively, toasts are typically triggered imperatively: `toast("Saved successfully")`.
4. **Animation**: Toasts enter and exit the viewport with transitions, requiring careful state management around the unmounting phase.

## ARIA Live Regions

Toasts use ARIA live regions to announce content to screen readers without moving focus:

| Role | Usage | Behavior |
|------|-------|----------|
| `role="status"` | Informational messages | Polite — waits for the current announcement to finish |
| `role="alert"` | Error or urgent messages | Assertive — interrupts the current announcement |

<Callout type="warning">
Use `role="alert"` sparingly. Assertive announcements interrupt whatever the screen reader is currently saying. For routine success messages, `role="status"` (polite) is appropriate. Reserve `role="alert"` for errors or critical actions.
</Callout>

The container that holds toasts should be a persistent live region in the DOM. If you add and remove the live region along with the toast, screen readers may not detect the change.

```tsx
// This container is always in the DOM
<div aria-live="polite" aria-atomic="false">
  {toasts.map((t) => (
    <div key={t.id} role="status">{t.message}</div>
  ))}
</div>
```

## The Toast Store

Because toasts are triggered imperatively, we need a store outside of React's render cycle. This store manages the queue and exposes methods to add, dismiss, and update toasts:

```tsx
type ToastVariant = "info" | "success" | "error" | "warning";

interface ToastData {
  id: string;
  message: string;
  variant: ToastVariant;
  duration: number;
  createdAt: number;
}

type Listener = () => void;

let toasts: ToastData[] = [];
let listeners: Set<Listener> = new Set();

function notify() {
  listeners.forEach((fn) => fn());
}

function subscribe(listener: Listener) {
  listeners.add(listener);
  return () => listeners.delete(listener);
}

function getSnapshot(): ToastData[] {
  return toasts;
}

let counter = 0;

function addToast(message: string, variant: ToastVariant = "info", duration = 5000): string {
  const id = `toast-${++counter}`;
  toasts = [...toasts, { id, message, variant, duration, createdAt: Date.now() }];
  notify();
  return id;
}

function dismissToast(id: string) {
  toasts = toasts.filter((t) => t.id !== id);
  notify();
}
```

<Callout type="tip">
We use `useSyncExternalStore` to subscribe React to this external store. This is the correct way to integrate non-React state with React 18+ concurrent features.
</Callout>

## Integrating with React via `useSyncExternalStore`

```tsx
import { useSyncExternalStore } from "react";

function useToasts(): ToastData[] {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
```

This hook triggers a re-render whenever the toast queue changes, and it is safe for concurrent rendering.

## Auto-Dismiss with Pause-on-Hover

Each toast has a timer that auto-dismisses it after the specified duration. The timer pauses when the user hovers over the toast or focuses within it:

```tsx
function useAutoDismiss(id: string, duration: number) {
  const [paused, setPaused] = React.useState(false);
  const remainingRef = React.useRef(duration);
  const startRef = React.useRef(Date.now());

  React.useEffect(() => {
    if (paused) {
      remainingRef.current -= Date.now() - startRef.current;
      return;
    }

    startRef.current = Date.now();
    const timer = setTimeout(() => {
      dismissToast(id);
    }, remainingRef.current);

    return () => clearTimeout(timer);
  }, [id, paused]);

  return {
    onMouseEnter: () => setPaused(true),
    onMouseLeave: () => setPaused(false),
    onFocus: () => setPaused(true),
    onBlur: () => setPaused(false),
  };
}
```

The key insight is tracking the *remaining* time. When the user hovers, we calculate how much time has elapsed and store the remainder. When they leave, we start a new timer with the remaining duration.

## Swipe-to-Dismiss

On touch devices, users expect to swipe toasts away. We track the horizontal pointer movement and dismiss when the swipe distance exceeds a threshold:

```tsx
function useSwipeToDismiss(id: string, threshold = 100) {
  const startXRef = React.useRef(0);
  const offsetRef = React.useRef(0);
  const [offset, setOffset] = React.useState(0);

  const handlers = {
    onPointerDown: (e: React.PointerEvent) => {
      startXRef.current = e.clientX;
      e.currentTarget.setPointerCapture(e.pointerId);
    },
    onPointerMove: (e: React.PointerEvent) => {
      if (!e.currentTarget.hasPointerCapture(e.pointerId)) return;
      const delta = e.clientX - startXRef.current;
      offsetRef.current = delta;
      setOffset(delta);
    },
    onPointerUp: () => {
      if (Math.abs(offsetRef.current) > threshold) {
        dismissToast(id);
      } else {
        setOffset(0);
      }
      offsetRef.current = 0;
    },
  };

  return { offset, handlers };
}
```

## Full Component Implementation

```tsx
import * as React from "react";

function ToastProvider({ children }: { children: React.ReactNode }) {
  const toasts = useToasts();

  return (
    <>
      {children}
      <div
        aria-live="polite"
        style={{
          position: "fixed",
          bottom: 16,
          right: 16,
          display: "flex",
          flexDirection: "column-reverse",
          gap: 8,
          zIndex: 9999,
          pointerEvents: "none",
        }}
      >
        {toasts.map((t) => (
          <ToastItem key={t.id} toast={t} />
        ))}
      </div>
    </>
  );
}

function ToastItem({ toast }: { toast: ToastData }) {
  const autoDismiss = useAutoDismiss(toast.id, toast.duration);
  const { offset, handlers: swipeHandlers } = useSwipeToDismiss(toast.id);
  const role = toast.variant === "error" ? "alert" : "status";

  return (
    <div
      role={role}
      data-variant={toast.variant}
      style={{
        pointerEvents: "auto",
        transform: `translateX(${offset}px)`,
        opacity: 1 - Math.abs(offset) / 200,
        transition: offset === 0 ? "transform 200ms, opacity 200ms" : "none",
      }}
      {...autoDismiss}
      {...swipeHandlers}
    >
      <p>{toast.message}</p>
      <button
        type="button"
        aria-label="Dismiss notification"
        onClick={() => dismissToast(toast.id)}
      >
        Close
      </button>
    </div>
  );
}

// Public imperative API
export function toast(message: string, variant?: ToastVariant, duration?: number) {
  return addToast(message, variant, duration);
}

export { ToastProvider, dismissToast };
```

## The Imperative API Pattern

The `toast()` function is a module-level export that can be called from anywhere — event handlers, utility functions, or even outside React components. This imperative pattern is common for toasts because they are triggered by actions, not by rendering state:

```tsx
// In an event handler
async function handleSave() {
  try {
    await saveDocument();
    toast("Document saved", "success");
  } catch {
    toast("Failed to save document", "error");
  }
}
```

## Toast Stacking and Limits

For production use, you should limit the number of visible toasts and queue the rest:

```tsx
const MAX_VISIBLE = 3;

function ToastProvider({ children }: { children: React.ReactNode }) {
  const allToasts = useToasts();
  const visibleToasts = allToasts.slice(-MAX_VISIBLE);
  // ...
}
```

## Key Takeaways

1. **Use `role="status"` for informational toasts** and `role="alert"` for errors — never overuse assertive announcements.
2. **Keep the live region container in the DOM permanently** so screen readers detect content changes.
3. **Use `useSyncExternalStore`** to bridge the imperative toast store with React's rendering.
4. **Track remaining time** for pause-on-hover, not elapsed time, so the timer resumes correctly.
5. **Swipe-to-dismiss** with `setPointerCapture` gives touch users a natural interaction.
6. **Limit visible toasts** and queue the rest to prevent visual clutter.

## Try It Yourself

<Exercise id="toast-basic" />
