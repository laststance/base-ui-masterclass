---
title: "Building a Slider Component"
description: "Learn how to build an accessible Slider with draggable thumb, keyboard arrow/Home/End support, role='slider' semantics, and CSS custom properties for track fill."
order: 2
isFree: false
---

# Building a Slider Component

A **Slider** lets users select a numeric value by dragging a thumb along a track. Sliders are common in volume controls, price filters, and color pickers. Building one from scratch involves pointer event handling, keyboard navigation, ARIA semantics, and CSS custom properties for the visual track fill.

## ARIA Slider Pattern

The WAI-ARIA specification defines the `slider` role:

| Attribute | Purpose | Example |
|-----------|---------|---------|
| `role="slider"` | Identifies the element as a slider | Applied to the thumb |
| `aria-valuenow` | Current value | `50` |
| `aria-valuemin` | Minimum value | `0` |
| `aria-valuemax` | Maximum value | `100` |
| `aria-valuetext` | Human-readable value | `"50%"` |
| `aria-orientation` | Direction of the slider | `"horizontal"` |
| `aria-label` | Accessible name | `"Volume"` |

Screen readers announce: "Volume, slider, 50, minimum 0, maximum 100."

<Callout type="info">
The `aria-valuetext` attribute is optional but valuable when the raw number lacks context. For a temperature slider, `aria-valuetext="72 degrees Fahrenheit"` is far more meaningful than `aria-valuenow="72"` alone.
</Callout>

## Keyboard Interaction

| Key | Action |
|-----|--------|
| `ArrowRight` / `ArrowUp` | Increment by step |
| `ArrowLeft` / `ArrowDown` | Decrement by step |
| `Home` | Set to minimum |
| `End` | Set to maximum |
| `Page Up` | Increment by large step (10x) |
| `Page Down` | Decrement by large step (10x) |

## Component API Design

```tsx
interface SliderProps {
  value?: number;
  defaultValue?: number;
  onValueChange?: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
  orientation?: "horizontal" | "vertical";
  disabled?: boolean;
}
```

Compound components:

- **`Slider.Root`** — Manages the value state, provides context, handles pointer events on the track.
- **`Slider.Track`** — The full track area.
- **`Slider.Range`** — The filled portion of the track representing the current value.
- **`Slider.Thumb`** — The draggable handle with ARIA `slider` role.

## Pointer Event Handling

The drag interaction follows a standard pointer capture pattern:

1. **`onPointerDown` on the track**: Calculate the value from the click position and start tracking.
2. **`onPointerMove`**: Update the value as the pointer moves. We use `setPointerCapture` to continue receiving events even when the pointer leaves the element.
3. **`onPointerUp`**: Release pointer capture and stop tracking.

```tsx
function calculateValue(
  clientX: number,
  trackRect: DOMRect,
  min: number,
  max: number,
  step: number,
): number {
  const percent = (clientX - trackRect.left) / trackRect.width;
  const raw = min + percent * (max - min);
  const stepped = Math.round((raw - min) / step) * step + min;
  return Math.min(Math.max(stepped, min), max);
}
```

<Callout type="warning">
Always use `setPointerCapture` on `pointerdown`. Without it, if the user drags the thumb quickly and the cursor leaves the track element, you will stop receiving `pointermove` events and the drag will "break."
</Callout>

## CSS Custom Properties for Track Fill

Instead of calculating inline widths in JavaScript, we expose CSS custom properties that the consumer can use for styling:

```tsx
const percentage = ((value - min) / (max - min)) * 100;
const style = {
  "--slider-value": `${percentage}%`,
  "--slider-thumb-position": `${percentage}%`,
} as React.CSSProperties;
```

This allows pure CSS styling:

```css
.slider-range {
  width: var(--slider-value);
}

.slider-thumb {
  left: var(--slider-thumb-position);
}
```

## Full Implementation

```tsx
import * as React from "react";

interface SliderContextValue {
  value: number;
  min: number;
  max: number;
  step: number;
  disabled: boolean;
  orientation: "horizontal" | "vertical";
  percentage: number;
  thumbRef: React.RefObject<HTMLDivElement | null>;
  trackRef: React.RefObject<HTMLDivElement | null>;
  updateValue: (next: number) => void;
}

const SliderContext = React.createContext<SliderContextValue | null>(null);

function useSliderContext() {
  const ctx = React.useContext(SliderContext);
  if (!ctx) throw new Error("Slider sub-components must be used within Slider.Root");
  return ctx;
}

function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

function Root({
  value: controlledValue,
  defaultValue = 0,
  onValueChange,
  min = 0,
  max = 100,
  step = 1,
  orientation = "horizontal",
  disabled = false,
  children,
  ...props
}: SliderProps & React.ComponentPropsWithoutRef<"div">) {
  const [internalValue, setInternalValue] = React.useState(controlledValue ?? defaultValue);
  const value = controlledValue ?? internalValue;
  const trackRef = React.useRef<HTMLDivElement>(null);
  const thumbRef = React.useRef<HTMLDivElement>(null);
  const percentage = ((value - min) / (max - min)) * 100;

  const updateValue = React.useCallback(
    (next: number) => {
      const clamped = clamp(next, min, max);
      const stepped = Math.round((clamped - min) / step) * step + min;
      const final = clamp(stepped, min, max);
      if (controlledValue === undefined) setInternalValue(final);
      onValueChange?.(final);
    },
    [min, max, step, controlledValue, onValueChange],
  );

  const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    if (disabled) return;
    const track = trackRef.current;
    if (!track) return;

    e.currentTarget.setPointerCapture(e.pointerId);
    const rect = track.getBoundingClientRect();
    const percent = orientation === "horizontal"
      ? (e.clientX - rect.left) / rect.width
      : (rect.bottom - e.clientY) / rect.height;
    const raw = min + percent * (max - min);
    updateValue(raw);
    thumbRef.current?.focus();
  };

  const handlePointerMove = (e: React.PointerEvent<HTMLDivElement>) => {
    if (disabled) return;
    if (!e.currentTarget.hasPointerCapture(e.pointerId)) return;
    const track = trackRef.current;
    if (!track) return;

    const rect = track.getBoundingClientRect();
    const percent = orientation === "horizontal"
      ? (e.clientX - rect.left) / rect.width
      : (rect.bottom - e.clientY) / rect.height;
    const raw = min + percent * (max - min);
    updateValue(raw);
  };

  const ctx = React.useMemo(
    () => ({ value, min, max, step, disabled, orientation, percentage, thumbRef, trackRef, updateValue }),
    [value, min, max, step, disabled, orientation, percentage, updateValue],
  );

  return (
    <SliderContext value={ctx}>
      <div
        data-orientation={orientation}
        data-disabled={disabled || undefined}
        style={{ "--slider-value": `${percentage}%`, "--slider-thumb-position": `${percentage}%` } as React.CSSProperties}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        {...props}
      >
        {children}
      </div>
    </SliderContext>
  );
}

function Track({ children, ...props }: React.ComponentPropsWithoutRef<"div">) {
  const { trackRef, orientation } = useSliderContext();

  return (
    <div ref={trackRef} data-orientation={orientation} {...props}>
      {children}
    </div>
  );
}

function Range(props: React.ComponentPropsWithoutRef<"div">) {
  const { percentage, orientation } = useSliderContext();

  const style = orientation === "horizontal"
    ? { width: `${percentage}%` }
    : { height: `${percentage}%` };

  return <div data-orientation={orientation} style={style} {...props} />;
}

function Thumb(props: React.ComponentPropsWithoutRef<"div">) {
  const { value, min, max, step, disabled, orientation, percentage, thumbRef, updateValue } =
    useSliderContext();

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (disabled) return;

    switch (e.key) {
      case "ArrowRight":
      case "ArrowUp":
        e.preventDefault();
        updateValue(value + step);
        break;
      case "ArrowLeft":
      case "ArrowDown":
        e.preventDefault();
        updateValue(value - step);
        break;
      case "Home":
        e.preventDefault();
        updateValue(min);
        break;
      case "End":
        e.preventDefault();
        updateValue(max);
        break;
      case "PageUp":
        e.preventDefault();
        updateValue(value + step * 10);
        break;
      case "PageDown":
        e.preventDefault();
        updateValue(value - step * 10);
        break;
    }
  };

  const positionStyle = orientation === "horizontal"
    ? { left: `${percentage}%` }
    : { bottom: `${percentage}%` };

  return (
    <div
      ref={thumbRef}
      role="slider"
      tabIndex={disabled ? -1 : 0}
      aria-valuenow={value}
      aria-valuemin={min}
      aria-valuemax={max}
      aria-orientation={orientation}
      aria-disabled={disabled || undefined}
      data-disabled={disabled || undefined}
      style={positionStyle}
      onKeyDown={handleKeyDown}
      {...props}
    />
  );
}

export const Slider = { Root, Track, Range, Thumb };
```

## Understanding `setPointerCapture`

When the user starts dragging, we call `setPointerCapture(pointerId)` on the root element. This does two critical things:

1. **All subsequent pointer events fire on the capturing element**, even if the pointer moves outside its bounds.
2. **The drag continues smoothly** without interruption when the cursor moves beyond the track area.

Without pointer capture, a fast drag would cause the cursor to leave the thumb element, and `pointermove` events would stop firing on it — resulting in a janky, broken interaction.

## Why the Thumb Gets `role="slider"`

In the ARIA model, the interactive element that the user manipulates receives the `slider` role. The track is a visual container with no semantic meaning. The thumb is where keyboard focus lives and where all ARIA value attributes are placed.

## Styling Patterns

```css
.slider-track {
  position: relative;
  height: 4px;
  background: var(--color-fill-secondary);
  border-radius: 2px;
}

.slider-range {
  position: absolute;
  height: 100%;
  background: var(--color-accent);
  border-radius: 2px;
}

.slider-thumb {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--color-accent);
  transform: translateX(-50%);
  cursor: grab;
}

.slider-thumb:active {
  cursor: grabbing;
}
```

## Key Takeaways

1. **Use `role="slider"`** on the thumb with `aria-valuenow`, `aria-valuemin`, and `aria-valuemax`.
2. **Arrow keys** step the value; Home/End jump to boundaries; Page Up/Down use a larger step.
3. **`setPointerCapture`** is essential for smooth drag interactions that survive cursor drift.
4. **CSS custom properties** (`--slider-value`, `--slider-thumb-position`) decouple visual styling from component internals.
5. **Snap to step** by rounding to the nearest step multiple before clamping to min/max.
6. **Both orientations** (horizontal and vertical) use the same logic with swapped axes.

## Try It Yourself

<Exercise id="slider-basic" />
