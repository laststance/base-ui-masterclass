---
title: "Building a Toolbar Component"
description: "Learn how to build an accessible Toolbar component with role='toolbar', aria-orientation, and roving tabindex for grouped interactive controls."
order: 3
isFree: false
---

# Building a Toolbar Component

A **Toolbar** is a container for a set of related controls — buttons, toggles, dropdown triggers, and other interactive elements. While it may seem like just a `<div>` with buttons inside, the ARIA `toolbar` role combined with roving tabindex transforms it into a first-class accessible widget that keyboard users can navigate efficiently.

## Why Use role="toolbar"?

Without the `toolbar` role, screen readers treat each button as an independent element. With it, assistive technology announces "toolbar" as a landmark, giving users context about the grouped controls. Combined with roving tabindex, the toolbar becomes a single tab stop in the page's tab order.

```
Without toolbar role:
[Tab] → Bold → [Tab] → Italic → [Tab] → Underline → [Tab] → Font Size → [Tab] → ...
                                                                         (5 tab stops)

With toolbar role + roving tabindex:
[Tab] → Bold → [ArrowRight] → Italic → [ArrowRight] → Underline → [Tab] → Next section
                                                                   (1 tab stop)
```

## ARIA Attributes

| Attribute | Applied To | Purpose |
|-----------|-----------|---------|
| `role="toolbar"` | Container | Identifies the element as a toolbar |
| `aria-label` | Container | Human-readable name for the toolbar |
| `aria-orientation` | Container | `"horizontal"` (default) or `"vertical"` |
| `aria-controls` | Container | Optional: references the element the toolbar acts on |

```tsx
<div role="toolbar" aria-label="Text formatting" aria-orientation="horizontal">
  <button>Bold</button>
  <button>Italic</button>
  <button>Underline</button>
</div>
```

## Toolbar vs. Tablist

Both Toolbar and Tablist use roving tabindex, but they serve different purposes:

| Feature | Toolbar | Tablist |
|---------|---------|---------|
| Purpose | Group of action controls | Tab navigation between panels |
| Selection | No mutual exclusion (multiple active) | Exactly one tab selected |
| `aria-selected` | Not used | Used on the active tab |
| Action on click | Performs action (toggle, execute) | Switches panel |
| ARIA role | `toolbar` | `tablist` |

## Component API Design

```tsx
interface ToolbarProps {
  orientation?: "horizontal" | "vertical";
}
```

Compound components:

- **`Toolbar.Root`** — Container with `role="toolbar"` and keyboard navigation.
- **`Toolbar.Button`** — An interactive item within the toolbar.
- **`Toolbar.Separator`** — A visual and semantic divider between groups.
- **`Toolbar.Link`** — A navigational link item.

## Full Implementation

```tsx
import * as React from "react";

// --- Context ---

interface ToolbarContextValue {
  orientation: "horizontal" | "vertical";
  registerItem: (element: HTMLElement) => () => void;
  handleKeyDown: (event: React.KeyboardEvent) => void;
  activeElement: HTMLElement | null;
}

const ToolbarContext = React.createContext<ToolbarContextValue | null>(null);

function useToolbarContext() {
  const ctx = React.useContext(ToolbarContext);
  if (!ctx) throw new Error("Toolbar sub-components must be used within Toolbar.Root");
  return ctx;
}

// --- Root ---

function Root({
  orientation = "horizontal",
  children,
  ...props
}: ToolbarProps & React.ComponentPropsWithoutRef<"div">) {
  const itemsRef = React.useRef<HTMLElement[]>([]);
  const [activeIndex, setActiveIndex] = React.useState(0);

  const registerItem = React.useCallback((element: HTMLElement) => {
    if (!itemsRef.current.includes(element)) {
      // Insert in DOM order by comparing positions
      const items = itemsRef.current;
      const index = items.findIndex(
        (item) => element.compareDocumentPosition(item) & Node.DOCUMENT_POSITION_FOLLOWING,
      );
      if (index === -1) {
        items.push(element);
      } else {
        items.splice(index, 0, element);
      }
    }
    return () => {
      itemsRef.current = itemsRef.current.filter((item) => item !== element);
    };
  }, []);

  const moveFocus = React.useCallback((nextIndex: number) => {
    const items = itemsRef.current;
    const clamped = ((nextIndex % items.length) + items.length) % items.length;
    setActiveIndex(clamped);
    items[clamped]?.focus();
  }, []);

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent) => {
      const items = itemsRef.current;
      const currentIdx = items.indexOf(event.currentTarget as HTMLElement);
      if (currentIdx === -1) return;

      const forwardKey = orientation === "vertical" ? "ArrowDown" : "ArrowRight";
      const backwardKey = orientation === "vertical" ? "ArrowUp" : "ArrowLeft";

      switch (event.key) {
        case forwardKey: {
          event.preventDefault();
          moveFocus(currentIdx + 1);
          break;
        }
        case backwardKey: {
          event.preventDefault();
          moveFocus(currentIdx - 1);
          break;
        }
        case "Home": {
          event.preventDefault();
          moveFocus(0);
          break;
        }
        case "End": {
          event.preventDefault();
          moveFocus(items.length - 1);
          break;
        }
      }
    },
    [orientation, moveFocus],
  );

  const ctx = React.useMemo(
    () => ({
      orientation,
      registerItem,
      handleKeyDown,
      activeElement: itemsRef.current[activeIndex] ?? null,
    }),
    [orientation, registerItem, handleKeyDown, activeIndex],
  );

  return (
    <ToolbarContext value={ctx}>
      <div
        role="toolbar"
        aria-orientation={orientation}
        data-orientation={orientation}
        {...props}
      >
        {children}
      </div>
    </ToolbarContext>
  );
}

// --- Button ---

function Button({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"button">) {
  const { registerItem, handleKeyDown, activeElement } = useToolbarContext();
  const ref = React.useRef<HTMLButtonElement | null>(null);

  React.useEffect(() => {
    if (ref.current) {
      return registerItem(ref.current);
    }
  }, [registerItem]);

  const isActive = ref.current === activeElement;

  return (
    <button
      type="button"
      ref={ref}
      tabIndex={isActive ? 0 : -1}
      onKeyDown={handleKeyDown}
      onFocus={() => {
        // Sync active index when focused via click
      }}
      {...props}
    >
      {children}
    </button>
  );
}

// --- Separator ---

function Separator(props: React.ComponentPropsWithoutRef<"div">) {
  const { orientation } = useToolbarContext();

  return (
    <div
      role="separator"
      aria-orientation={orientation === "horizontal" ? "vertical" : "horizontal"}
      data-orientation={orientation === "horizontal" ? "vertical" : "horizontal"}
      {...props}
    />
  );
}

// --- Link ---

function Link({
  children,
  ...props
}: React.ComponentPropsWithoutRef<"a">) {
  const { registerItem, handleKeyDown, activeElement } = useToolbarContext();
  const ref = React.useRef<HTMLAnchorElement | null>(null);

  React.useEffect(() => {
    if (ref.current) {
      return registerItem(ref.current);
    }
  }, [registerItem]);

  const isActive = ref.current === activeElement;

  return (
    <a
      ref={ref}
      tabIndex={isActive ? 0 : -1}
      onKeyDown={handleKeyDown}
      {...props}
    >
      {children}
    </a>
  );
}

export const Toolbar = { Root, Button, Separator, Link };
```

## Usage Example

```tsx
<Toolbar.Root aria-label="Text formatting">
  <Toolbar.Button onClick={() => toggleBold()}>
    <BoldIcon />
  </Toolbar.Button>
  <Toolbar.Button onClick={() => toggleItalic()}>
    <ItalicIcon />
  </Toolbar.Button>
  <Toolbar.Button onClick={() => toggleUnderline()}>
    <UnderlineIcon />
  </Toolbar.Button>

  <Toolbar.Separator />

  <Toolbar.Button onClick={() => alignLeft()}>
    <AlignLeftIcon />
  </Toolbar.Button>
  <Toolbar.Button onClick={() => alignCenter()}>
    <AlignCenterIcon />
  </Toolbar.Button>
  <Toolbar.Button onClick={() => alignRight()}>
    <AlignRightIcon />
  </Toolbar.Button>

  <Toolbar.Separator />

  <Toolbar.Link href="/help">Help</Toolbar.Link>
</Toolbar.Root>
```

## Handling Mixed Control Types

Real toolbars often contain different types of controls: toggle buttons, dropdowns, and links. Each type needs slightly different behavior:

| Control Type | tabIndex | Activation |
|-------------|----------|-----------|
| Button | Roving tabindex | Click / Enter / Space |
| Toggle Button | Roving tabindex + aria-pressed | Click / Enter / Space |
| Link | Roving tabindex | Click / Enter |
| Dropdown Trigger | Roving tabindex | Click / Enter / Space / ArrowDown |

The roving tabindex applies uniformly — all interactive elements within the toolbar participate in arrow key navigation, regardless of type.

## Separator Semantics

The `Toolbar.Separator` uses `role="separator"` to create a semantic boundary between groups of controls. Note that the separator's `aria-orientation` is the **opposite** of the toolbar's orientation:

- In a horizontal toolbar, separators are vertical dividers.
- In a vertical toolbar, separators are horizontal dividers.

Screen readers announce the separator, helping users understand the grouping of controls.

## Styling Considerations

```css
[role="toolbar"] {
  display: flex;
  gap: 4px;
  align-items: center;
}

[role="toolbar"][data-orientation="vertical"] {
  flex-direction: column;
}

[role="separator"] {
  width: 1px;
  height: 24px;
  background: var(--color-border);
}

[data-orientation="horizontal"] [role="separator"] {
  width: 1px;
  align-self: stretch;
}

[data-orientation="vertical"] [role="separator"] {
  height: 1px;
  align-self: stretch;
}
```

## Key Takeaways

1. **`role="toolbar"`** groups related controls into a single accessible landmark.
2. **Roving tabindex** reduces the toolbar to a single tab stop with arrow key navigation.
3. **`aria-orientation`** determines which arrow keys are used for navigation.
4. **Separators** use the opposite orientation of the toolbar to create visual and semantic dividers.
5. **Mixed control types** (buttons, links, toggles) all participate in the same roving tabindex.
6. **Register items in DOM order** using `compareDocumentPosition` for correct arrow key navigation regardless of render order.
7. The toolbar pattern is reused in **menu bars, tab lists, and tree views** with minor variations.
