---
title: "Building a Headless Input"
description: "Learn how to build a headless Input component supporting uncontrolled and controlled modes, aria-invalid integration, and data attributes for state-driven styling."
order: 2
isFree: false
---

# Building a Headless Input

The Input is your first component that deals with **value state** -- the distinction between controlled and uncontrolled components. This is a foundational concept that every form-related component in Base UI relies on.

## Controlled vs. Uncontrolled

React inputs can operate in two modes:

| Mode | State owner | Props used | When to use |
|------|------------|------------|-------------|
| **Uncontrolled** | The DOM | `defaultValue` | Simple forms, no real-time validation |
| **Controlled** | Your component | `value` + `onChange` | Form libraries, live validation, derived state |

A headless Input must support **both** modes transparently. The consumer decides which mode to use; the component does not care.

## Step 1: Define the Props

```tsx
import * as React from "react";

interface InputProps extends React.ComponentPropsWithoutRef<"input"> {
  /**
   * Optional render prop for custom element rendering.
   * Accepts a ReactElement that will be cloned with computed props.
   */
  render?: React.ReactElement;
  ref?: React.Ref<HTMLInputElement>;
}
```

We extend native `<input>` props so the consumer gets full HTML attribute support out of the box -- `type`, `placeholder`, `name`, `required`, `pattern`, and everything else.

## Step 2: Track Internal State for Data Attributes

The headless Input exposes state through data attributes. Base UI tracks several states:

```tsx
export function Input({
  render,
  disabled,
  ref,
  defaultValue,
  value,
  onChange,
  onFocus,
  onBlur,
  ...props
}: InputProps) {
  const [focused, setFocused] = React.useState(false);
  const [dirty, setDirty] = React.useState(false);
  const [touched, setTouched] = React.useState(false);

  // Determine if the input has a value (works for both modes)
  const isFilled = value != null ? value !== "" : dirty;

  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    setFocused(true);
    onFocus?.(e);
  };

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    setFocused(false);
    setTouched(true);
    onBlur?.(e);
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setDirty(true);
    onChange?.(e);
  };

  // Build data attributes
  const dataAttributes = {
    "data-disabled": disabled || undefined,
    "data-focused": focused || undefined,
    "data-dirty": dirty || undefined,
    "data-touched": touched || undefined,
    "data-filled": isFilled || undefined,
  };

  const elementProps = {
    ...props,
    ref,
    disabled,
    defaultValue,
    value,
    onChange: handleChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ...dataAttributes,
  };

  if (render) {
    return React.cloneElement(render, elementProps);
  }

  return <input {...elementProps} />;
}
```

### Data attribute breakdown

| Attribute | When it appears | Use case |
|-----------|----------------|----------|
| `data-disabled` | Input is disabled | Grey out, reduce opacity |
| `data-focused` | Input has focus | Show focus ring |
| `data-dirty` | Value has been changed | Show "unsaved changes" indicator |
| `data-touched` | Input has been blurred at least once | Show validation errors only after interaction |
| `data-filled` | Input has a non-empty value | Float label pattern |

## Step 3: Integrating aria-invalid

When an input is invalid, screen readers need to announce it. The `aria-invalid` attribute does this:

```tsx
interface InputProps extends React.ComponentPropsWithoutRef<"input"> {
  render?: React.ReactElement;
  ref?: React.Ref<HTMLInputElement>;
}

export function Input({
  render,
  disabled,
  ref,
  "aria-invalid": ariaInvalid,
  ...props
}: InputProps) {
  // ... state tracking from above ...

  const dataAttributes = {
    "data-disabled": disabled || undefined,
    "data-focused": focused || undefined,
    "data-dirty": dirty || undefined,
    "data-touched": touched || undefined,
    "data-filled": isFilled || undefined,
    "data-invalid": ariaInvalid || undefined,
    "data-valid": ariaInvalid === false ? true : undefined,
  };

  const elementProps = {
    ...props,
    ref,
    disabled,
    "aria-invalid": ariaInvalid,
    ...dataAttributes,
  };

  if (render) {
    return React.cloneElement(render, elementProps);
  }

  return <input {...elementProps} />;
}
```

Now CSS can respond to validation state:

```css
.my-input[data-invalid] {
  border-color: var(--color-error);
}

.my-input[data-valid] {
  border-color: var(--color-success);
}
```

## Step 4: Usage Examples

### Uncontrolled (simple form)

```tsx
<form>
  <Input
    name="email"
    type="email"
    placeholder="you@example.com"
    defaultValue=""
    required
  />
  <button type="submit">Submit</button>
</form>
```

### Controlled (live validation)

```tsx
function EmailInput() {
  const [email, setEmail] = React.useState("");
  const isValid = email.includes("@");

  return (
    <Input
      value={email}
      onChange={(e) => setEmail(e.target.value)}
      aria-invalid={email.length > 0 ? !isValid : undefined}
      placeholder="you@example.com"
    />
  );
}
```

### Polymorphic rendering

```tsx
<Input render={<textarea />} placeholder="Write your message..." />
```

## Recap

| Concept | What you learned |
|---------|-----------------|
| Controlled vs. uncontrolled | Support both via `value`/`onChange` and `defaultValue` |
| State tracking | `dirty`, `touched`, `focused`, `filled` for lifecycle awareness |
| `aria-invalid` | Mirror validity into both ARIA and data attributes |
| Data attributes | Expose all state for CSS-driven styling |

The Input teaches you the **state duality** pattern that recurs in every form component. Next, we will build the Separator -- the simplest semantic HTML component.

<Exercise id="input-basic" />
